local fn = vim.fn
local fmt = string.format

local a      = require 'packer.async'
local config = require 'packer.config'
local log    = require 'packer.log'
local util   = require 'packer.util'
local fsstate = require 'packer.fsstate'

local display = require 'packer.display'

local packer_plugins = require 'packer.plugin'.plugins

local Display = display.Display

local record M
  clean   : function()
  install : function()
  update  : function(string|table, ...: string)
  sync    : function(string|table, ...: string)
  status  : function()
end

local function open_display(): Display
  return display.display.open({
    diff = function(plugin: Plugin, commit: string, callback: function): {string}
      local plugin_type = require'packer.plugin_types'[plugin.type]
      return plugin_type.diff(plugin, commit, callback)
    end,
    revert_last = function(plugin: Plugin)
      local plugin_type = require'packer.plugin_types'[plugin.type]
      plugin_type.revert_last(plugin)
    end,
    update = M.update,
    install = M.install
  })
end

local function run_tasks(tasks: {a.Thunk}, disp: Display): {any}
  if #tasks == 0 then
    log.info 'Nothing to do!'
    return
  end

  local function check(): boolean
    return not disp.running
  end

  local limit = config.max_jobs and config.max_jobs or #tasks

  log.debug 'Running tasks'
  disp:update_headline_message(string.format('updating %d / %d plugins', #tasks, #tasks))
  return a.join(limit, check, tasks)
end

local function measure(f: function()): number
  local start_time = vim.loop.hrtime()
  f()
  return (vim.loop.hrtime() - start_time) / 1e9
end

local function helptags_stale(dir: string): boolean
  local glob = fn.glob

  -- Adapted directly from minpac.vim
  local txts = glob(util.join_paths(dir, '*.txt'), true, true)
  vim.list_extend(txts, fn.glob(util.join_paths(dir, '*.[a-z][a-z]x'), true, true))

  if #txts == 0 then
    return false
  end

  local tags = glob(util.join_paths(dir, 'tags'), true, true)
  vim.list_extend(tags, glob(util.join_paths(dir, 'tags-[a-z][a-z]'), true, true))

  if #tags == 0 then
    return true
  end

  local txt_newest = math.max(unpack(vim.tbl_map(fn.getftime, txts)))
  local tag_oldest = math.min(unpack(vim.tbl_map(fn.getftime, tags)))
  return txt_newest > tag_oldest
end

local function update_helptags(results: {string:Display.Result})
  local paths = {}
  for plugin_name, r in pairs(results as {string:Display.Result}) do
    if not r.err then
      paths[#paths+1] = packer_plugins[plugin_name].install_path
    end
  end

  for _, dir in ipairs(paths) do
    local doc_dir = util.join_paths(dir, 'doc')
    if helptags_stale(doc_dir) then
      log.info('Updating helptags for ' .. doc_dir)
      vim.cmd('silent! helptags ' .. fn.fnameescape(doc_dir))
    end
  end
end

local function load_plugin(plugin: Plugin)
  if plugin.opt then
    vim.cmd.packadd(plugin.name)
    return
  end

  vim.o.runtimepath = vim.o.runtimepath .. ',' .. plugin.install_path

  for _, path in ipairs {
    util.join_paths(plugin.install_path, 'plugin', '**', '*.vim'),
    util.join_paths(plugin.install_path, 'plugin', '**', '*.lua'),
    util.join_paths(plugin.install_path, 'after', 'plugin', '**', '*.vim'),
    util.join_paths(plugin.install_path, 'after', 'plugin', '**', '*.lua'),
  } do
    local ok, files = pcall(fn.glob, path, false, true)
    if not ok then
      if (files as string):find('E77') then  -- E77: Too many file names
        vim.cmd('silent exe "source ' .. path .. '"')
      else
        error(files)
      end
    else
      for _, file in ipairs(files) do
        vim.cmd.source{file, mods = {silent=true}}
      end
    end
  end
end

local post_update_hook = a.sync(function(plugin: Plugin, disp: Display): {string}
  local plugin_name = plugin.full_name
  if plugin.run or not plugin.opt then
    a.main()
    load_plugin(plugin)
  end

  if not plugin.run then
    return
  end

  disp:task_update(plugin_name, 'running post update hooks...')

  for _, run_task in ipairs(plugin.run) do
    if run_task is function then
      local ok, err = pcall(run_task, plugin, disp)
      if not ok then
        return { 'Error running post update hook: ' .. vim.inspect(err) }
      end
    elseif type(run_task) == 'string' and run_task:sub(1, 1) == ':' then
      -- Run a vim command
      a.main()
      vim.cmd(run_task:sub(2))
    else
      local jobs = require 'packer.jobs'
      local jr = jobs.run(run_task, { cwd = plugin.install_path })

      if not jr:ok() then
        return {string.format('Error running post update hook: %s', table.concat(jr.output.data.stderr, '\n'))}
      end
    end
  end
end, 2)

local install_task = a.sync(function(plugin: Plugin, disp: Display, installs: {string:Display.Result}): string, {string}
  disp:task_start(plugin.full_name, 'installing...')

  local plugin_type = require'packer.plugin_types'[plugin.type]

  local err = plugin_type.installer(plugin, disp)

  if not err then
    err = post_update_hook(plugin, disp)
  end

  if not disp.items then
    disp.items = {}
  end

  if not err then
    disp:task_succeeded(plugin.full_name, 'installed')
    log.debug(fmt('Installed %s', plugin.full_name))
  else
    disp:task_failed(plugin.full_name, 'failed to install')
    log.debug(fmt('Failed to install %s: %s', plugin.full_name, vim.inspect(err)))
    disp.items[plugin.name] = {
      displayed = false,
      lines = err,
      plugin = plugin
    }
  end

  installs[plugin.name] = { err = err }
  return plugin.name, err
end, 3)

local function get_install_tasks(
  plugins: {string:Plugin},
  missing_plugins: {string},
  disp: Display,
  installs: {string:Display.Result}
): {a.Thunk}
  if #missing_plugins == 0 then
    return {}
  end

  local tasks = {}
  for _, v in ipairs(missing_plugins) do
    tasks[#tasks+1] = a.curry(install_task, plugins[v], disp, installs)
  end

  return tasks
end

local function move_plugin(plugin: Plugin, moves: {string:Display.Result}, fs_state: fsstate.FSState)
  local from: string
  local to: string
  if plugin.opt then
    from = util.join_paths(config.start_dir, plugin.name)
    to = util.join_paths(config.opt_dir, plugin.name)
  else
    from = util.join_paths(config.opt_dir, plugin.name)
    to = util.join_paths(config.start_dir, plugin.name)
  end

  fs_state.start[to] = plugin.name
  fs_state.opt[from] = nil
  fs_state.dirty[from] = nil

  moves[plugin.name] = {from = from, to = to}

  -- NOTE: If we stored all plugins somewhere off-package-path and used symlinks to put them in the
  -- right directories, this could be lighter-weight
  local success, msg = os.rename(from, to)
  if not success then
    log.error(fmt('Failed to move %s to %s: %s', from, to, msg))
    moves[plugin.name] = {err = {msg}}
  else
    log.debug(fmt('Moved %s from %s to %s', plugin.name, from, to))
  end
end

local update_task = a.sync(function(plugin: Plugin, disp: Display, updates: {string:Display.Result}, opts: table): string, {string}
  local plugin_name = plugin.full_name
  disp:task_start(plugin_name, 'updating...')

  if plugin.lock then
    disp:task_succeeded(plugin_name, 'locked')
    return
  end

  local plugin_type = require'packer.plugin_types'[plugin.type]

  local err = plugin_type.updater(plugin, disp, opts)
  local msg = 'up to date'
  if not err and plugin.type == 'git' then
    local revs = plugin.revs
    local actual_update = revs[1] ~= revs[2]
    if actual_update then
      msg = fmt('updated: %s...%s', revs[1], revs[2])
      if not opts.preview_updates then
        log.debug(fmt('Updated %s', plugin_name))
        err = post_update_hook(plugin, disp)
      end
    else
      msg = 'already up to date'
    end
  end

  if not err then
    disp:task_succeeded(plugin_name, msg)
  else
    disp:task_failed(plugin_name, 'failed to update')
    log.debug(fmt('Failed to update %s: %s', plugin_name, plugin.err))
  end

  updates[plugin_name] = { err = err }
  return plugin_name, err
end, 4)

local function get_update_tasks(
  plugins: {string:Plugin},
  update_plugins: {string},
  disp: Display,
  updates: {string:Display.Result},
  opts: table
): {a.Thunk}
  local tasks = {}
  for _, v in ipairs(update_plugins) do
    local plugin = plugins[v]
    if not plugin then
      log.error(fmt('Unknown plugin: %s', v))
    end
    if plugin and not plugin.lock then
      tasks[#tasks+1] = a.curry(update_task, plugin, disp, updates, opts)
    end
  end

  if #tasks == 0 then
    log.info 'Nothing to update!'
  end

  return tasks
end

local function fix_plugin_types(
  plugins: {string:Plugin},
  extra_plugins: {string},
  moves: {string:Display.Result},
  fs_state: fsstate.FSState
)
  log.debug 'Fixing plugin types'
  -- NOTE: This function can only be run on plugins already installed
  for _, v in ipairs(extra_plugins) do
    local plugin = plugins[v]
    local wrong_install_dir = util.join_paths(plugin.opt and config.start_dir or config.opt_dir, plugin.name)
    if vim.loop.fs_stat(wrong_install_dir) then
      move_plugin(plugin, moves, fs_state)
    end
  end
  log.debug 'Done fixing plugin types'
end

-- Filter out options specified as the first argument to update or sync
-- returns the options table and the plugin names
local function filter_opts_from_plugins(first: table|string, ...: string): table, {string}
  local args = { ... }
  local opts = {}
  if not vim.tbl_isempty(args) then
    if first is table then
      table.remove(args, 1)
      opts = first
    elseif first == '--preview' then
      table.remove(args, 1)
      opts = { preview_updates = true }
    end
  end
  if config.preview_updates then
    opts.preview_updates = true
  end
  return opts, #args > 0 and args or vim.tbl_keys(packer_plugins)
end

-- Find and remove any plugins not currently configured for use
local do_clean = a.sync(function(plugins: {string:Plugin}, fs_state: fsstate.FSState, removals: {string})
  fs_state = fs_state or fsstate.get_fs_state(plugins)

  log.debug 'Starting clean'
  local extra_plugins = fs_state.extra

  if not next(extra_plugins) then
    log.info 'Already clean!'
    return
  end

  a.main()

  local lines = {}
  for path, _ in pairs(extra_plugins) do
    table.insert(lines, '  - ' .. path)
  end

  if config.autoremove or display.display.ask_user('Removing the following directories. OK? (y/N)', lines) then
    if removals then
      for r, _ in pairs(extra_plugins) do
        removals[#removals+1] = r
      end
    end
    for path, _ in pairs(extra_plugins) do
      local result = vim.fn.delete(path, 'rf')
      if result == -1 then
        log.warn('Could not remove ' .. path)
      end
      extra_plugins[path] = nil
    end
    log.debug('Removed ' .. vim.inspect(extra_plugins))
  else
    log.warn 'Cleaning cancelled!'
  end
end, 4)

--- Install operation:
--- Installs missing plugins, then updates helptags
M.install = a.sync(function()
  local fs_state = fsstate.get_fs_state(packer_plugins)
  local missing_plugins = vim.tbl_values(fs_state.missing)
  if #missing_plugins == 0 then
    log.info 'All configured plugins are installed'
    return
  end

  a.main()

  log.debug 'Gathering install tasks'

  local disp = open_display()
  local installs: {string:Display.Result} = {}

  local delta = measure(function()
    local install_tasks = get_install_tasks(packer_plugins, missing_plugins, disp, installs)
    run_tasks(install_tasks, disp)

    a.main()
    update_helptags(installs)
  end)

  disp:final_results({installs = installs}, delta)
end)

--- Update operation:
--- Takes an optional list of plugin names as an argument. If no list is given,
--- operates on all managed plugin then updates installed plugins and updates
--- helptags. - Options can be specified in the first argument as either a table -
--- or explicit `'--preview'`.
M.update = a.void(function(first: string|table, ...:string)
  local opts, update_plugins = filter_opts_from_plugins(first, ...)
  local fs_state = fsstate.get_fs_state(packer_plugins)
  local _, installed_plugins = util.partition(vim.tbl_values(fs_state.missing), update_plugins)

  local updates = {}

  a.main()

  local disp = open_display()

  local delta = measure(function()
    local tasks = {}

    a.main()

    log.debug 'Gathering update tasks'
    vim.list_extend(tasks, get_update_tasks(packer_plugins, installed_plugins, disp, updates, opts))

    run_tasks(tasks, disp)

    a.main()
    update_helptags(updates)
  end)

  disp:final_results({updates=updates}, delta)
end)

--- Sync operation:
--- Takes an optional list of plugin names as an argument. If no list is given,
--- operates on all managed plugins. Fixes plugin types, installs missing
--- plugins, then updates installed plugins and updates helptags and rplugins
--- Options can be specified in the first argument as either a table
--- or explicit `'--preview'`.
M.sync = a.void(function(first: string|table, ...:string)
  local plugins = packer_plugins
  local opts, update_plugins = filter_opts_from_plugins(first, ...)
  local fs_state = fsstate.get_fs_state(packer_plugins)

  local extra_plugins = util.partition(vim.tbl_values(fs_state.extra), update_plugins)

  local results: Display.Results = {
    moves = {},
    removals = {},
    installs = {},
    updates = {}
  }

  fix_plugin_types(packer_plugins, extra_plugins, results.moves, fs_state)

  -- Even though we may have moved some dirty plugins, they may still be dirty
  -- for a different reason so recalculate fs_state
  fs_state = fsstate.get_fs_state(packer_plugins)

  do_clean(packer_plugins, fs_state, results.removals)

  local missing_plugins, installed_plugins = util.partition(vim.tbl_values(fs_state.missing), update_plugins)

  a.main()

  local disp = open_display()

  local delta = measure(function()
    local tasks = {}

    log.debug 'Gathering install tasks'
    vim.list_extend(tasks, get_install_tasks(plugins, missing_plugins, disp, results.installs))

    a.main()

    log.debug 'Gathering update tasks'
    vim.list_extend(tasks, get_update_tasks(plugins, installed_plugins, disp, results.updates, opts))

    run_tasks(tasks, disp)

    a.main()
    update_helptags(vim.tbl_extend('error', results.installs, results.updates))
  end)

  disp:final_results(results, delta)
end)

M.status = a.sync(function()
  if packer_plugins == nil then
    log.warn 'packer_plugins table is nil! Cannot run packer.status()!'
    return
  end

  open_display():set_status(packer_plugins)
end)

--- Clean operation:
-- Finds plugins present in the `packer` package but not in the managed set
M.clean = a.void(function()
  do_clean(packer_plugins)
end)

return M
